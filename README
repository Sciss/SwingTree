Scala Swing Tree Wrapper Design
by Ken Scambler

This project provides a Scala wrapper for Java's JTree class, and aims to be suitable for eventual inclusion in the official Scala Swing library.
The design was initiated in the Scala debate forum in February 2010: http://scala-programming-language.1934581.n4.nabble.com/scala-swing-JTree-wrapper-design-td2004809.html#a2004809

CONTENTS:
I) Design Goals
II) Use Cases
III) Background
IV) Tree Model
V) Events
VI) Selection
VII) Cell Renderers
VIII) Cell Editors
IX) Broader design

I) DESIGN GOALS
- Wrap a sensible subset of JTree functionality that directly accomodates the most common JTree use cases, while allowing direct access to the underlying peer
- Consider tree-view features of other desktop UI environments, and assess suitability for adaption, based on utility, orthogonality within Scala Swing, and harmony with Scala and Scala Swing's conventions and goals.
- Identify areas of JTree functionality that can be simplified or removed through Scala language features
- Consistency with the conventions and design goals of the Scala Swing library (http://www.scala-lang.org/sid/8)
- Consistency with the style and conventions of comparable Scala Swing wrappers such as ListView, ComboBox and Table
- Source and binary backward-compability with existing Scala Swing library
- Design such that future modifications to the Tree wrapper can preserve source and binary backward-compatibility
- Identify underlying commonalities that arise between Tree and other current and future Scala Swing components, and propose new abstractions to represent them
- Design such that potential future components such as ListTable or TreeTable could be facilitated in a style consistent with Tree and other wrappers.

II) USE CASES
I have considered the following use-cases as broadly representative of JTree usage:
1) A small, fixed tree as a navigation mechanism
2) Some object graph with nodes of different types at different levels, ie Customers and Orders.
3) A graphical representation of some external data structure in tree form.
4) A representation of the filesystem, nested into directories
5) Some tree structure where the data can be dynamically edited through the Tree-interface, mutating a node in the underlying structure.
6) Some tree structure where the underlying structure can be dynamically mutated through adding, removing and moving nodes within in the displayed tree.
7) A deeply nested, infinite, or cyclic graph structure that needs to be constructed lazily. (This is particularly arduous in Java, but is easily supportable in Scala, as demonstrated below.)
8) Using Java Swing's Data Transfer facility to drag and drop data within, to, or from a Tree component.  Satisfying this use-case would require a design that provides library-wide support of Data Transfer.

III) BACKGROUND
Java Swing minimally represents its tree structure via an implementation of the TreeModel interface, which could itself define a tree structure, or wrap arbitrary underlying node data.  It: 
- Is untyped
- Allows node values within the structure to replaced
- Requires TreeModelEvents to be fired under certain situations.  
- Always has a single root node, although this can be hidden and ignored. 
- Provides a facility to automatically extract a TreeModel structure from nested untyped Object[], Vectors, or Hashtables.  Typically users would manually populate a TreeModel using or extending the default implementations, namely a DefaultTreeModel containing DefaultMutableTreeNodes. 
- Where lazily defined tree structures are required, supports listening to TreeWillExpand events and manually adding child nodes on demand.

In Scala Swing, the actual Swing model classes are typically hidden, and some natural representation of user data is used instead.  For example: 
- ListView[A] is initialised with a Seq[A].  The Seq[A] is accessable and assignable through the listData property. The list cannot be mutated once assigned.
- Table is untyped, and initialised with row and column dimensions, or as a Seq[Seq[Any]]. It subsequently exposes the actual underlying javax.swing.table.TableModel, although it is conveniently accessible and mutable through the apply(Int,Int) and updateCell(Int, Int, Any) methods. The data can also be indirectly mutated through a Table.Editor. 
- ComboBox[A] is initialised with a Seq[A], although it is subsequently neither directly accessable nor assignable.  The data can be indirectly mutated through a ComboBox.Editor.

Other UI environments have their own ways of representing tree-view data:

SWT's Tree component: 
- Explicitly stores its data inside the recursive TreeItem data structure, which can contain arbitary untyped user data.
- Requires users to manually create TreeItem elements and their children
- Is not directly given its children; TreeItems are simply constructed with a Tree or TreeNode parameter, with no further connection being necessary.
- Is a "TreeTable" out of the box, also maintaining a column model.
- Implicitly supports multiple root nodes, where multiple TreeItems are created with the same Tree argument.
- Offers two means of lazily defining a tree structure: initialising the Tree with the SWT.VIRTUAL style and handling the SWT.SetData event, or handling the SWT.Expand event, manually creating new TreeItems in either case.

.NET's TreeView component:
- Explicitly stores its data inside a TreeNodeCollection, which contains recursive TreeNodes that can wrap arbitrary untyped user data.  
- Requires users to manually create TreeNode elements and populate the TreeNodeCollection. 
- Allows the TreeNodeCollection to contain multiple root nodes. 
- Is integrated with standard .NET collections, as TreeNodeCollection extends the IList interface, and may be iterated like a normal collection.
- Where lazily defined tree structures are required, supports adding a handler to the AfterExpand event to manually add child nodes on demand.

QT's QTreeView component:
- Abstractly represents its data in a QAbstractItemModel, which is a common base class for QListView, QTableView and QTreeView models
- Supports "TreeTable" columns through the QAbstractItemModel
- Has a special subclass of QAbstractItemModel, QDirModel, to represent a filesystem tree model.
- Has a standard model implementation QStandardItemModel that can be used for QTreeView, QTableView, and QListView.
- Supports lazily defined tree (or table or list) structures through subclassing QAbstractItemModel and overriding certain methods.

Cocoa's NSTreeController:
- Abstractly represents its data with one or more rootnodes, and a string that when messaged to a node object will return more child objects.
- Nodes can be any type, as long as they are capable of accepting some message to produce an array of child nodes.

Groovy's SwingBuilder:
- Provides a convenient and concise DSL syntax for creating and configuring JTrees, but neither enhances nor simplifies Java's native JTree functionality.

We can make some observations regarding the tree-view implementations described above:
- The tree's data is untyped in each case, despite many if not most common use cases being tree structures with a single underlying node type. 
- In most cases the tree structure must be manually created within some prescribed node class, wrapping the underlying node values. 
- Swing and QT's tree model implementations are more abstract than .NET and SWT, but appear to have slightly more complex usage patterns as a result.
- QT's unified representation of list-view, table-view and tree-view models demonstrates the significant commonality between the three.
- We can regret the lack of in-built support for a column model in JTree - we must carefully consider to what extent this can or should be supported in Scala Swing.
- For Swing, SWT and .NET, lazily populating the tree in requires the use of the observer pattern, with all its attendant disadvantages described in http://lamp.epfl.ch/~imaier/pub/DeprecatingObserversTR2010.pdf .  Canonical usage examples are without exception verbose, messy, and have the lazy node creation logic dispersed into multiple locations.
- QT's lazy population model appears simpler to implement, at the cost of higher coupling and reduced flexibility.
- Cocoa's use of Objective C dynamic message-passing allows simple and natural definitions of tree structures.

IV) TREE MODEL
We can immediately identify some desirable features for the Scala Swing Tree:
- A tree model with statically typed elements.
- The tree model must be mutable.
- Natural support for lazy and virtual tree stuctures
- Some natural way of defining the tree structure from arbitrary user data without requiring manual node-by-node population
- Tree model integration with Scala Collections, with monadic properties out of the box, as found in .NET.
- Some common interface between Tree and other "item view" widgets, as in QT
- Some common interface for Renderer and Editor support which is now partly or wholly supported in an ad-hoc fashion for ComboBox, ListView and Table.
- An invisible internal data structure, for consistency with ListView and Table, and to maintain flexibility.
- Support for multiple root nodes.

A structure that substantially supports these aims and the use-cases enumerated above, is some root node, and a function that provides children given a node.  The type parameter A is invariant, as the underlying structure must be both accessed and mutated.

class Tree[A](root: A, children: A => Seq[A])

This is a good start; however since our tree is strongly typed, what if we wanted multiple root nodes where there is no natural A to sit above them?  We need multiple roots:

class Tree[A](roots: Seq[A], children: A => Seq[A])

This can be used to populate the tree eagerly or on-demand; it could describe a physical data structure, or some virtual structure like integer sequences.  However, we need to encapsulate this in a class, so that we can access it, assign it, mutate it, and integrate it with Scala Collections:  

class TreeModel[A](val roots: Seq[A], val children: A => Seq[A]) extends Iterable[A] {lazy val peer: javax.swing.tree.TreeModel}
class Tree[A](treeModel: TreeModel[A])

Like other Scala Swing wrappers, a no-args constructor should be supported:

new Tree[Foo] {
  treeData = new TreeModel(roots, childFunc) // named for consistency with ListView.listData
}

Although this somewhat breaks the pattern of hiding the data model in Scala Swing, we do need post-initialisation access to the data, and no existing collection in the Scala library fits an abstract hierarchical data structure very well; this solution best matches the criteria listed above.

For convenience, we can follow the example of scala.swing.Button and provide an apply method on the companion object of TreeModel, which will give us varargs for the roots, and type inference on A for the children function:

object TreeModel {
  def apply[A](roots: A*)(children: A => Seq[A]): Tree[A]
}

This could also be applied to Tree, but this less likely to be useful; most tree implementations will require extra detail such as renderers in the class body.

The use cases enumerated above can be satisfied by this design as follows:

1) Small fixed tree for navigation
case class Node[A](value: A, children: Node[A]*)
val menuItems = 
  Node("Hobbies", 
    Node("Skateboarding"), 
    Node("Indoor", 
      Node("Chess", 
        Node("Chinese"), 
        Node("International")),
      Node("Draughts")),
    Node("Spelunking"))
      
new Tree[Node[String]](TreeModel(menuItems)(_.children))


2) Some object graph with nodes of different types at different levels, ie Customers and Orders.
case class Customer(customerId: Long, name: String, address: String, orders: List[Order])
case class Order(orderId: Long, product: String, quantity: Int)
val customerList: List[Customer] = //...

new Tree[Any] {
  treeData = TreeModel(customerList) {
    case c: Customer => c.orders
    case _: Order => Nil
  }
}

3) A graphical representation of some external data structure in tree form.
val xml = <root><ch id="b">Foo</ch></root>
new Tree[Node](Seq(xml), _.child filter (_.text.trim.nonEmpty))

4) A representation of the filesystem, nested into directories
new Tree[File](Seq(new File(".")), f => if (f.isDirectory) f.listFiles else Seq())

5&6) Mutation of the underlying structure: see section on Editors

7) A deeply nested, infinite, or cyclic graph structure that needs to be constructed lazily.
// Recursively factorise all integers from 1 to 1000 (infinite depth):
new Tree[Int](TreeModel(1000)(n => 1 to n filter (n % _ == 0))) // Tree is evaluated lazily

V) EVENTS
JTree has one of the most complex event models in Swing.  The events notify observers of changes in the tree model, changes in selection state, and of expanding and collapsing nodes.  We can follow the usual Scala Swing pattern of using case classes to define events in a hierarchy:

ComponentEvent
  +-- trait TreeEvent[A]
          +-- TreePathSelected[A]
          +-- TreeExpansionEvent[A]
          |      +-- TreeCollapsed[A]
          |      +-- TreeExpanded[A]
          |      +-- TreeWillCollapse[A]
          |      +-- TreeWillExpand[A]
          +-- TreeModelEvent[A]
                  +-- TreeNodesChanged[A]
                  +-- TreeNodesInserted[A]
                  +-- TreeNodesRemove[A]
                  +-- TreeStructureChanged[A]


VI) SELECTION
In Swing's JTree, a unit of selection is either a row (integer), or a TreePath.  

A row index is a relative coordinate; it can only identify cells that are currently displayed, and which cell a row index refers to varies depending on what nodes are displayed.

A TreePath is an absolute coordinate. It describes the sequence of successive nodes from the root required to reach a node.  Its semantics are similar to scala.List, and I don't believe TreePath deserves to be propagated or wrapped in Scala.  scala.List[A] fits well in this role.  However, it is probably appropriate to provide a type alias, such as:
object Tree {type Path[A] = List[A]}

Following the design in Tree's cousins, ListView and Table, we provide an object `selection` that is the publisher of the Tree's selection events, and contains further nested objects `paths` and `rows` to represent the current selection state:

class Tree[A] {
  object selection extends Publisher {
    object paths extends Set[Path[A]]
    object rows extends Set[Int]
  }
}

VII) CELL RENDERERS 
In Java Swing, there are several components (ie JTree, JTable, JList, JComboBox) that are composed of "cells", each of which contains some arbitrary data value, and can be selected.  Each cell is rendered using a pluggable cell renderer, which provides some Swing component (such as a JLabel) to use as a rubber stamp, as per the GoF flyweight pattern.

The cell renderers are represented by separate, but similar interfaces:

[Java]
interface ListCellRenderer { // Used by both JList and JComboBox
  Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus);
}
  
interface TableCellRenderer {
  Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column); 
}

interface TreeCellRenderer {
  Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus); 
}

Despite the different names and types, each contains essentially the same information:
  1) The actual list/table/tree component itself
  2) The value of the cell
  3) Whether or not the cell is selected
  4) Whether or not the cell has the input focus
  5) Some coordinate to locate the cell independently (ie index, row/column, row)

In addition to the above, the TreeRenderer wants to know whether the cell (node) is expanded, and whether it is a leaf node.

Scala Swing has so far taken a minimal thin wrapper approach to cell renderers, without imposing any commonality.  For instance the ListView and Table cell renderers are almost identical to their Java equivalents, although they make the parameter order more consistent:

// object ListView
abstract class Renderer[-A] {
  def peer: javax.swing.ListCellRenderer
  def componentFor(list: ListView[_], isSelected: Boolean, focused: Boolean, a: A, index: Int): Component
}

// object Table
abstract class Renderer[-A] {
  def peer: javax.swing.table.TableCellRenderer
  def componentFor(table: Table, isSelected: Boolean, hasFocus: Boolean, a: A, row: Int, column: Int): Component
}

In addition, further utilities are provided for a generic implementation of a renderer (described in http://www.scala-lang.org/sid/8): 

object ListView {
  class Renderer[-A] // Renderer base class
  class AbstractRenderer[-A, C <: Component] extends Renderer[A] // Provides standard pre-configuration
  implicit object GenericRenderer extends Renderer[Any] // Implicit generic implementation
  
  object Renderer {
    class Wrapped[A] extends Renderer[A] // Wraps naked javax.swing.ListCellRenderers
    def apply[A, B: Renderer](f: A=>B): Renderer[A] // Creates a renderer for As, given A => B where Bs are implicitly renderable
    def wrap[A](r: javax.swing.ListCellRenderer): Renderer[A]
  }
}

class ListView[A] {
  def renderer : ListView.Renderer[A]
  def renderer_= (r: ListView.Renderer[A]) : Unit
}

object Table {
  class Renderer[-A] // Renderer base class
  class AbstractRenderer[-A, C<:Component] extends Renderer[A] // Provides standard pre-configuration
  class LabelRenderer[A] extends AbstractRenderer[A, Label] // Renderer implementation using a label: requires A => (Icon, String)
}

class Table {
  // Could be overridden to customize; otherwise no access or assignment for Renderers.
  protected def rendererComponent(isSelected: Boolean, focused: Boolean, row: Int, column: Int): Component
}

class ComboBox[A] {
  def renderer : ListView.Renderer[A] // Reuses ListView's renderer capabilities.
  def renderer_= (r: ListView.Renderer[A]) : Unit
}


The ListView and Table APIs can be profitably reproduced for Tree:

object Tree {
  class Renderer[-A] // Renderer base class
  class AbstractRenderer[-A, C <: Component] extends Renderer[A] // Provides standard pre-configuration
  implicit object GenericRenderer extends Renderer[Any] // Implicit generic implementation
  class LabelRenderer[A] extends AbstractRenderer[A, Label] // Renderer implementation using a label: requires A => (Icon, String)
  
  object Renderer {
    class Wrapped[A] extends Renderer[A] // Wraps naked javax.swing.tree.TreeCellRenderers
    def apply[A, B: Renderer](f: A=>B): Renderer[A] // Creates a renderer for A, given A => B where B is implicitly renderable
    def wrap[A](r: javax.swing.tree.TreeCellRenderer): Renderer[A]
  }
}

class Tree[A] {
  def renderer : Tree.Renderer[A]
  def renderer_= (r: Tree.Renderer[A]) : Unit
}


VIII) CELL EDITORS
Several Java components that contain cells also support cell editors.  Unlike renderers, most cell editors share a common interface: javax.swing.CellEditor.  They operate on some common assumptions:

1) The editor belongs to a host component that is composed of value-containing cells, which may be mutable and selectable.
2) At any point in time, the editor is either currently editing, or not.
3) While editing, the editor represents a single cell in the host component.
4) While editing, the editor holds a value distinct from the value of the cell it represents.
5) Not every cell in the host component is necessarily editable; the editor may decide which.
6) If not currently editing, editing can be started on a cell, triggering an event.
7) If currently editing, editing can be stopped, triggering an event and transferring the editor value to the cell.
8) If currently editing, editing can be cancelled, triggering an event and discarding the editor value.
9) The editor may decide whether any edited cell should be selected when edited.

The various editor interfaces and classes form the following hierarchy:

CellEditor
  +-- TableCellEditor----------------+
  |                                  |
  +-- TreeCellEditor---------------+ |
  |     +-- DefaultTreeCellEditor  | |
  |                                | |
  +-- AbstractCellEditor           | |
        +----------------- DefaultCellEditor

JComboBox has a separate editor interface, ComboBoxEditor, which provides functionality specific to editing the current value of the JComboBox; it doesn't operate on the same assumptions as the others.  JList cannot be edited.

The CellEditor interface provides functionality to perform the steps enumerated above; like renderers, each control's editor interface has a method which must be overridden to configure and provide the editor component, shown here:

[Java]
interface TableCellEditor extends CellEditor {
  Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column);
}

interface TreeCellEditor extends CellEditor {
  Component getTreeCellEditorComponent(JTree tree, Object value, boolean isSelected, boolean expanded, boolean leaf, int row);
}
  
Like the cell renderers, each one contains similar information:
  1) The actual table/tree component itself
  2) The value of the cell
  3) Whether or not the cell is selected
  4) Some coordinate to locate the cell independently (ie row/column, row)

IX) BROADER DESIGN:

